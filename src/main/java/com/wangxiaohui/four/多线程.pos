{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[{"parent":"root","children":[{"parent":"72fdac8eeff7","children":[],"id":"a38b7682cc55","title":"CAS&nbsp;CompareAndSwap 自旋"},{"parent":"72fdac8eeff7","children":[],"id":"fbb0bb429c36","title":"volatile&nbsp;关键字"},{"parent":"72fdac8eeff7","children":[{"parent":"cde73b1c700b","children":[],"id":"57a0ae884856","title":"并发压力跟锁性能的关系：<br>1、压力非常小，性能本身要求就不高；<br>2、压力一般的情况下，无锁更快，大部分都一次写入；<br>3、压力非常大时，自旋导致重试过多，资源消耗很大。"}],"id":"cde73b1c700b","title":"应用场景"}],"id":"72fdac8eeff7","title":"Atomic类"},{"parent":"root","children":[{"parent":"1b245dcd5cf6","children":[],"id":"c4f718364670","title":"LongAdder&nbsp;的改进思路：<br>1、AtomicInteger&nbsp;和&nbsp;AtomicLong&nbsp;里的&nbsp;value&nbsp;是所有线程竞争读写的热点数据；<br>2、将单个&nbsp;value&nbsp;拆分成跟线程一样多的数组&nbsp;Cell[]；&nbsp;3、每个线程写自己的&nbsp;Cell[i]++，最后对数组求和"},{"parent":"1b245dcd5cf6","children":[{"parent":"4d55c27b13a2","children":[],"id":"ad7a77ee7e83","title":"快排"},{"parent":"4d55c27b13a2","children":[],"id":"f9ebd9e24b79","title":"G1 GC"},{"parent":"4d55c27b13a2","children":[],"id":"48812e91a5ef","title":"ConcurrentHashMap"}],"id":"4d55c27b13a2","title":"应用场景"}],"id":"1b245dcd5cf6","title":"LongAdder 分段"},{"parent":"root","children":[{"parent":"a94ad78aecd1","children":[],"id":"e7ad53fba930","title":"AbstractQueuedSynchronizer，即队列同步器。它是构建锁或者其他同步组件的基础"},{"parent":"a94ad78aecd1","children":[],"id":"12a27d249a86","title":"Semaphore&nbsp;-&nbsp;信号量 可以设置信号量 读写锁"},{"parent":"a94ad78aecd1","children":[],"id":"6145f0cb35af","title":"CountdownLatch&nbsp;阻塞主线程，N&nbsp;个子线程满足条件时主线程继续"},{"parent":"a94ad78aecd1","children":[],"id":"9a61907b63a7","title":"CyclicBarrier&nbsp;任务执行到一定阶段,&nbsp;等待其他任务对齐，阻塞&nbsp;N&nbsp;个线程时所有线程被唤醒继续"},{"parent":"a94ad78aecd1","children":[],"id":"fd7bf8f7a20f","title":"Future/FutureTask/CompletableFuture 处理多线程异常"}],"id":"a94ad78aecd1","title":"AQS"},{"parent":"root","children":[{"parent":"b4a370e4f65a","children":[{"parent":"0cad44b4de98","children":[],"id":"d94e1d67f3e5","title":"1.&nbsp;使用对象头标记字(Object&nbsp;monitor)<br>2.&nbsp;Synchronized&nbsp;方法优化<br>3.&nbsp;偏向锁:&nbsp;BiaseLock"},{"parent":"0cad44b4de98","children":[],"id":"0fa7d971a184","title":"问题<br>1、同步块的阻塞无法中断（不能&nbsp;Interruptibly）<br>2、同步块的阻塞无法控制超时（无法自动解锁）<br>3、同步块无法异步处理锁（即不能立即知道是否可以拿到锁）<br>4、同步块无法根据条件灵活的加锁解锁（即只能跟同步块范围一致）"}],"id":"0cad44b4de98","title":"synchronized"},{"parent":"b4a370e4f65a","children":[{"parent":"3a16d6c2f920","children":[],"id":"ce801d895d1e","title":"1.&nbsp;使用方式灵活可控<br>2.&nbsp;性能开销小<br>3.&nbsp;锁工具包:&nbsp;java.util.concurrent.locks"},{"parent":"3a16d6c2f920","children":[],"id":"eb61074cb3c5","title":"锁"}],"id":"3a16d6c2f920","title":"lock"}],"id":"b4a370e4f65a","title":"锁"}],"note":"","margin":{"childMarginW":40,"childMarginH":20,"marginW":70,"marginH":30},"watermark":"","children":[{"parent":"root","lineStyle":{"randomLineColor":"rgb(153,204,255)"},"children":[{"parent":"82ac6f1c6eea","children":[{"parent":"7bbe59a94079","children":[],"id":"6f0993710dcc","title":"如果在java运行中只有守护线程在运行的时候，系统就会停止。执行可以被放弃的任务"},{"parent":"7bbe59a94079","children":[],"id":"48511162ba7e","title":"守护线程有：1、（并行的垃圾处理器）2、setDeamon(true)可以变成守护线程"}],"id":"7bbe59a94079","title":"守护线程：&nbsp;"},{"parent":"82ac6f1c6eea","children":[{"parent":"8933fb55d33c","children":[],"id":"6809892ac21f","title":"NEW 初始状态"},{"parent":"8933fb55d33c","children":[],"id":"c018d63e7a43","title":"RUNNABLE 可运行状态&nbsp; &nbsp;thread.start()可以让线程进去可运行状态并自动执行"},{"parent":"8933fb55d33c","children":[],"id":"0442a5013b44","title":"RUNNING 运行中&nbsp;&nbsp;thread.run()可以让线程进去可运行状态"},{"parent":"8933fb55d33c","children":[],"id":"5f88bf340e79","title":"READY 就绪状态"},{"parent":"8933fb55d33c","children":[],"id":"e1fece17963f","title":"WAITING 等待状态 thread.wait()&nbsp; 和thread.notify()&nbsp; object的方法"},{"parent":"8933fb55d33c","children":[],"id":"0d191a993fac","title":"TIMED_WAITING 限时等待被唤醒状态&nbsp;thread.sleep() 线程"},{"parent":"8933fb55d33c","children":[],"id":"5666eea941c5","title":"BLOCKED 阻塞状态 获取锁等资源没获取到"},{"parent":"8933fb55d33c","children":[],"id":"604c1a3916b9","title":"TERMINATED 终止状态"},{"parent":"8933fb55d33c","children":[],"id":"5e36f17d8532","title":"LockSupport unpark park 暂停线程"}],"id":"8933fb55d33c","title":"线程状态"}],"id":"82ac6f1c6eea","title":"thread"},{"parent":"root","lineStyle":{"randomLineColor":"rgb(232, 124, 37)"},"children":[{"parent":"310b7a49b219","children":[{"parent":"f9dee66f9e32","children":[],"id":"7f3ac03b6162","title":"volatile 适用场景 单线程写 多线程读&nbsp; 尽量不用&nbsp; 替代 Atomic =原子操作类"},{"parent":"f9dee66f9e32","children":[{"parent":"df8826c6b0fb","children":[],"id":"688db08b19e0","title":"synchronized"},{"parent":"df8826c6b0fb","children":[],"id":"df403db32ec9","title":"lock"}],"id":"df8826c6b0fb","title":"锁也可以保证可见性"}],"id":"f9dee66f9e32","title":"可见性"},{"parent":"310b7a49b219","children":[{"parent":"e55d87cc5905","children":[],"id":"f15e550e6330","title":"1.&nbsp;程序次序规则：一个线程内，按照代码先后顺序"},{"parent":"e55d87cc5905","children":[],"id":"53855e5c5999","title":"2.&nbsp;锁定规则：一个&nbsp;unLock&nbsp;操作先行发生于后面对同一个锁的&nbsp;lock&nbsp;操作"},{"parent":"e55d87cc5905","children":[],"id":"137bc1b16aeb","title":"3.&nbsp;Volatile&nbsp;变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作"},{"parent":"e55d87cc5905","children":[],"id":"8e3f58bddf87","title":"4.&nbsp;传递规则：如果操作&nbsp;A&nbsp;先行发生于操作&nbsp;B，而操作&nbsp;B&nbsp;又先行发生于操作&nbsp;C，则可以得出&nbsp;A&nbsp;先于&nbsp;C"},{"parent":"e55d87cc5905","children":[],"id":"34d698d6e23c","title":"5.&nbsp;线程启动规则：Thread&nbsp;对象的&nbsp;start()&nbsp;方法先行发生于此线程的每个一个动作"},{"parent":"e55d87cc5905","children":[],"id":"1a76bc96b249","title":"6.&nbsp;线程中断规则：对线程&nbsp;interrupt()&nbsp;方法的调用先行发生于被中断线程的代码检测到中断事件的发生"},{"parent":"e55d87cc5905","children":[],"id":"a82856740126","title":"7.&nbsp;线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过&nbsp;Thread.join()&nbsp;方法结束、<br>Thread.isAlive()&nbsp;的返回值手段检测到线程已经终止执行"},{"parent":"e55d87cc5905","children":[],"id":"625b1a844fa4","title":"8.&nbsp;对象终结规则：一个对象的初始化完成先行发生于他的&nbsp;finalize()&nbsp;方法的开始"}],"id":"e55d87cc5905","title":"有序性"},{"parent":"310b7a49b219","children":[],"id":"787a866c15c3","title":"原子性"}],"id":"310b7a49b219","title":"线程安全"},{"parent":"root","lineStyle":{"randomLineColor":"rgb(0, 94, 170)"},"children":[{"parent":"a8859d6d67ce","children":[{"parent":"3b1fefc2385c","children":[],"id":"bee76d3853fb","title":"ExecutorService<br>shutdown()：停止接收新任务，原来的任务继续执行<br>shutdownNow()：停止接收新任务，原来的任务停止执行<br>boolean&nbsp;awaitTermination(timeOut,&nbsp;unit)：阻塞当前线程，返回是否线程都执行完"}],"id":"3b1fefc2385c","title":"submit&nbsp;方法&nbsp;-&gt;&nbsp;有返回值，用&nbsp;Future&nbsp;封装 异常可以被get到<br>execute&nbsp;方法&nbsp;-&gt;&nbsp;无返回值"},{"parent":"a8859d6d67ce","children":[{"parent":"a18dc2d0a498","children":[],"id":"996c8f03c6c4","title":"1.&nbsp;ThreadPoolExecutor.AbortPolicy:&nbsp;丢弃任务并抛出&nbsp;RejectedExecutionException异常<br>2.&nbsp;ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常<br>3.&nbsp;ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝<br>的任务<br>4.&nbsp;ThreadPoolExecutor.CallerRunsPolicy：由调用线程（提交任务的线程）处理该任务"}],"id":"a18dc2d0a498","title":"策略"},{"parent":"a8859d6d67ce","children":[{"parent":"3f38d65cab2d","children":[],"id":"119de50036d5","title":"1.&nbsp;ArrayBlockingQueue：规定大小的&nbsp;BlockingQueue，其构造必须指定大小。其所含的对象<br>是&nbsp;FIFO&nbsp;顺序排序的。<br>2.&nbsp;LinkedBlockingQueue：大小不固定的&nbsp;BlockingQueue，若其构造时指定大小，生成的<br>BlockingQueue&nbsp;有大小限制，不指定大小，其大小有&nbsp;Integer.MAX_VALUE&nbsp;来决定。其所含<br>的对象是&nbsp;FIFO&nbsp;顺序排序的。<br>3.&nbsp;PriorityBlockingQueue：类似于&nbsp;LinkedBlockingQueue，但是其所含对象的排序不是&nbsp;FIFO，<br>而是依据对象的自然顺序或者构造函数的&nbsp;Comparator&nbsp;决定。<br>4.&nbsp;SynchronizedQueue：特殊的&nbsp;Blocking"}],"id":"3f38d65cab2d","title":"对列"},{"parent":"a8859d6d67ce","children":[{"parent":"7b87ea2a93ec","children":[],"id":"56113daac04a","title":"1.&nbsp;newSingleThreadExecutor\n创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的\n线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。\n2.newFixedThreadPool\n创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到\n最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。\n3.&nbsp;newCachedThreadPool\n创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，\n那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。\n此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。\n4.newScheduledThreadPool\n创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。"},{"parent":"7b87ea2a93ec","children":[],"id":"acc2de141272","title":"1、如果是&nbsp;CPU&nbsp;密集型应用，则线程池大小设置为&nbsp;N&nbsp;或&nbsp;N+1<br>2、如果是&nbsp;IO&nbsp;密集型应用，则线程池大小设置为&nbsp;2N&nbsp;或&nbsp;2N+2"}],"id":"7b87ea2a93ec","title":"创建线程池"}],"id":"a8859d6d67ce","title":"线程池"},{"parent":"root","children":[{"parent":"05bb259e5f79","children":[{"parent":"2693e7e5a85f","children":[{"parent":"5f732aeefc12","children":[],"id":"65508d12aa0b","title":"基本特点:基于数组，便于按&nbsp;index&nbsp;访问，超过数组需要扩容，扩容成本较高"},{"parent":"5f732aeefc12","children":[],"id":"2d48e7cd226e","title":"用途：大部分情况下操作一组数据都可以用&nbsp;ArrayList"},{"parent":"5f732aeefc12","children":[],"id":"2ad5c9ca9633","title":"原理：使用数组模拟列表，默认大小10，扩容&nbsp;x1.5，newCapacity&nbsp;=&nbsp;oldCapacity&nbsp;+&nbsp;\n(oldCapacity&nbsp;&gt;&gt;&nbsp;1)"},{"parent":"5f732aeefc12","children":[],"id":"ded897a180ca","title":"安全问题：<br>1、写冲突：<br>-&nbsp;两个写，相互操作冲突<br>2、读写冲突：<br>-&nbsp;读，特别是&nbsp;iterator&nbsp;的时候，数据个数变了，拿到了非预期数据或者报错<br>-&nbsp;产生&nbsp;ConcurrentModificationException"}],"id":"5f732aeefc12","title":"ArrayList"},{"parent":"2693e7e5a85f","children":[{"parent":"0041583844ac","children":[],"id":"2bcefc3891ac","title":"基本特点：使用链表实现，无需扩容"},{"parent":"0041583844ac","children":[],"id":"2a203323ae86","title":"用途：不知道容量，插入变动多的情况"},{"parent":"0041583844ac","children":[],"id":"56789b39a7bc","title":"原理：使用双向指针将所有节点连起来"},{"parent":"0041583844ac","children":[],"id":"40e6cc8bca2a","title":"安全问题：<br>1、写冲突：<br>-&nbsp;两个写，相互操作冲突<br>2、读写冲突：<br>-&nbsp;读，特别是&nbsp;iterator&nbsp;的时候，数据个数变了<br>，拿到了非预期数据或者报错-&nbsp;产生&nbsp;ConcurrentModificationException"}],"id":"0041583844ac","title":"LinkedList"},{"parent":"2693e7e5a85f","children":[{"parent":"c8193110c027","children":[],"id":"5be223ffca51","title":"核心改进原理：<br>1、写加锁，保证不会写混乱<br>2、写在一个&nbsp;Copy&nbsp;副本上，而不是原始数据上<br>（GC&nbsp;young&nbsp;区用复制，old&nbsp;区用本区内的移动）<br>读写分离 （快照模式）"}],"id":"c8193110c027","title":"CopyOnWriteArrayList"}],"id":"2693e7e5a85f","title":"List"},{"parent":"05bb259e5f79","children":[],"id":"ce3e4e3126f0","title":"Set"},{"parent":"05bb259e5f79","children":[],"id":"e2c7c9ebe7cd","title":"Queue"},{"parent":"05bb259e5f79","children":[{"parent":"7a427cb545c0","children":[{"parent":"f22621caf029","children":[],"id":"094bc91e77b2","title":"基本特点：空间换时间，哈希冲突不大的情况下查找数据性能很高"},{"parent":"f22621caf029","children":[],"id":"1dd48c15169b","title":"用途：存放指定&nbsp;key&nbsp;的对象，缓存对象"},{"parent":"f22621caf029","children":[],"id":"f60f34ad26c1","title":"原理：使用&nbsp;hash&nbsp;原理，存&nbsp;k-v&nbsp;数据，初始容量16，扩容x2，负载因子0.75\nJDK8&nbsp;以后，在链表长度到8&nbsp;&amp;&nbsp;数组长度到64时，使用红黑树"},{"parent":"f22621caf029","children":[],"id":"599424546fa6","title":"安全问题：\n1、写冲突\n2、读写问题，可能会死循环\n3、keys()无序问题"}],"id":"f22621caf029","title":"HashMap"},{"parent":"7a427cb545c0","children":[{"parent":"892e64bd9f4c","children":[],"id":"08c63458b87a","title":"基本特点：继承自&nbsp;HashMap，对&nbsp;Entry&nbsp;集合添加了一个双向链表\n用途：保证有序，特别是&nbsp;Java8&nbsp;stream&nbsp;操作的&nbsp;toMap&nbsp;时使用\n原理：同&nbsp;LinkedList，包括插入顺序和访问顺序"},{"parent":"892e64bd9f4c","children":[],"id":"3f0c010bbad7","title":"安全问题：\n同&nbsp;HashMap"}],"id":"892e64bd9f4c","title":"LinkedHashMap"},{"parent":"7a427cb545c0","children":[{"parent":"aed1be402eb7","children":[],"id":"3f9bef274ffb","title":"分段锁 java 7（和分库分表比较像）<br>默认16个&nbsp;Segment，降低锁粒度。<br>concurrentLevel&nbsp;=&nbsp;16"},{"parent":"aed1be402eb7","children":[],"id":"17d35491a9ed","title":"java&nbsp; cas"}],"id":"aed1be402eb7","title":"ConcurrentHashMap"}],"id":"7a427cb545c0","title":"Map"},{"parent":"05bb259e5f79","children":[],"id":"6bf005f2fa1c","title":"Dictionary"}],"id":"05bb259e5f79","title":"collection"},{"parent":"root","children":[{"parent":"87b6d1cfcdb8","children":[{"parent":"ed22af69d880","children":[],"id":"cff8263532b1","title":"public&nbsp;ThreadLocal()&nbsp;构造方法<br>protected&nbsp;T&nbsp;initialValue()&nbsp;覆写-设置初始默认值<br>void&nbsp;set(T&nbsp;value)&nbsp;设置本线程对应的值<br>void&nbsp;remove()&nbsp;清理本线程对应的值<br>减少显式传递参数<br>"}],"id":"ed22af69d880","title":"线程安全操作利器&nbsp;-&nbsp;ThreadLocal 可以看做context 模式<br>"},{"parent":"87b6d1cfcdb8","children":[],"id":"177918e0325c","title":"stream.parallel&nbsp; 会自动新建一个一个线程次 线程数是cpu的核数"},{"parent":"87b6d1cfcdb8","children":[{"parent":"825567297fa7","children":[],"id":"87fa68439236","title":"1.&nbsp;粒度<br>2.&nbsp;性能<br>3.&nbsp;重入<br>4.&nbsp;公平<br>5.&nbsp;自旋锁（spinlock）<br>6.&nbsp;场景:&nbsp;脱离业务场景谈性能都是耍流氓"}],"id":"825567297fa7","title":"加锁需要考虑的问题"},{"parent":"87b6d1cfcdb8","children":[],"id":"bfb413320132","title":"线程间协作与通信"}],"id":"87b6d1cfcdb8","title":"线程相关内容或经验总结"}],"root":true,"theme":"customise_101291b47b71","id":"root","title":"多线程","structure":"mind_free"}},"meta":{"exportTime":"2022-03-28 23:57:11","member":"5ab0b662e4b0d248ffd3b513","diagramInfo":{"creator":"5ab0b662e4b0d248ffd3b513","created":"2022-03-26 15:58:37","modified":"2022-03-28 23:56:29","title":"多线程","category":"mind_free"},"id":"623ec7ad1efad40756c7222b","type":"ProcessOn Schema File","version":"1.0"}}